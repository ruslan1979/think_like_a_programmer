/* Измененный последний пример из предыдущей главы.
    Задача: декодировать сообщение
    Некое сообщение было закодировано в виде текстового потока, который должен быть
    прочитан символ за символом. Поток содержит последовательность целых чисел, разделенных запятыми.
    Каждое из этих чисел — положительное целое, которое может быть представлено типом int
    языка С++. Однако то, какой символ, представлен тем или иным целым числом, зависит от текущего режима
    декодирования. Всего существует три режима: верхний регистр, нижний регистр и пунктуация.
    В режиме верхнего регистра каждое целое число представляет прописную букву: целое
    число, взятое по модулю 27, означает букву алфавита (где 1 = A и так далее). Таким
    образом, введенное значение 143 в режиме верхнего регистра будет означать букву
    H, так как 143 по модулю 27 равняется 8, а H — восьмая буква латинского алфавита.
    Режим нижнего регистра работает аналогичным образом, но со строчными буквами: остаток от деления целого числа на 27 представляет строчную букву (где 1 = a и так далее).
    Таким образом, введенное значение 56 в режиме верхнего регистра будет означать букву
    b, так как 56 по модулю 27 равняется 2, а b — вторая буква латинского алфавита.
    В режиме пунктуации целое число уже берется по модулю 9 и согласно интерпретации
    в приведенной ниже табл. 2.3. Таким образом, 19 по модулю 9 будет означать восклицательный знак, так как 19 по модулю 9 равняется 1.
    В начале каждого сообщения устанавливается режим декодирования верхнего регистра. Каждый раз, когда результат операции деления по модулю
    (27 или 9, в зависимости от режима) равен 0, происходит переключение режима декодирования. Если в
    текущий момент установлен режим декодирования верхнего регистра, то происходит
    переключение на режим декодирования нижнего регистра. Если же в текущий момент
    установлен режим декодирования нижнего регистра, то происходит переключение на
    режим декодирования пунктуации. Если установлен режим декодирования пунктуации, то происходит переключение на режим декодирования верхнего регистра.

    Пример:
        зашифрованное:  18,12312,171,763,98423,1208,216,11,500,18,241,0,32,20620,27,10
        расшифрованное: Right? Yes!
*/
#include <iostream>

using namespace std;


int main() {
    char outputCharacter;
    enum modeType {UPPERCASE, LOWERCASE, PUNCTUATION};

    modeType mode = UPPERCASE;
    char digitChar;

    do {
        digitChar = cin.get();
        int number = (digitChar - '0');
        digitChar = cin.get();
        while ((digitChar != 10) && (digitChar != ',')) {
            number = number * 10 + (digitChar - '0');
            digitChar = cin.get();
        }

        switch (mode) {
            case UPPERCASE:
                number = number % 27;
                if (number == 0) {
                    mode = LOWERCASE;
                    continue;
                }
                else
                    outputCharacter = number + 'A' - 1;
                break;
            case LOWERCASE:
                number = number % 27;
                if (number == 0) {
                    mode = PUNCTUATION;
                    continue;
                }
                else
                    outputCharacter = number + 'a' - 1;
                break;
            case PUNCTUATION:
                number = number % 9;
				const char punctuation[8] = {'!', '?', ',', '.', ' ', ';', '"', '\''};

                if (number == 0) {
                    mode = UPPERCASE;
                    continue;
                }
                else
                    outputCharacter = punctuation[number - 1];
                break;
        }

        cout << outputCharacter;

    } while (digitChar != 10);

    cout << endl;

    return 0;
}
